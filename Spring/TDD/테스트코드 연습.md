## 🎃 테스트코드 연습

> TDD 베이스의 코드 작성 연습
> 

---

### ✅ 요구사항

- 단순 비밀번호를 검증하는 기능 추가
- 비밀번호는 최소 8자 이상 12자 이하여야 한다.
- 비밀번호가 8자 미만 또는 12자 초과인 경우 *IllegalArgumentException* 예외를 발생시킨다.

### ✅ 코드작성

> `PasswordValidator` : 비밀번호 검증
> 

*PasswordValidatorTest.class*

```java
public class PasswordValidatorTest {

    @DisplayName("비밀번호가 최소 8자 이상, 12자 이하면 예외가 발생하지 않는다.")
    @Test
    void validatePasswordTest() {
    
        String password = "abcdefghij";
        PasswordValidator passwordValidator = new PasswordValidator();

        assertThatCode(() -> passwordValidator.validate(password))
                .doesNotThrowAnyException();
    }

    @DisplayName("비밀번호가 8자 미만 또는 12자 초과하는 경우 IllegalArgumentException 예외가 발생한다.")
    @Test
    void invalidatePasswordTest() {
      
        assertThatCode(() -> passwordValidator.validate("abc"))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessage("비밀번호는 최소 8자 이상 12자 이하여야 한다.");
    }
    
}

```

위 작성한 코드는 경계 값에 대한 테스트가 없으므로 테스트를 추가해야 한다.

길이가 각각 7, 13인 값을 테스트하는 코드를 작성하는데, 어노테이션을 활용하여 쉽게 작성할 수 있다.

```java
    @DisplayName("비밀번호가 8자 미만 또는 12자 초과하는 경우 IllegalArgumentException 예외가 발생한다.")
    @ParameterizedTest
    @ValueSource(strings = {"aabbcce", "aabbccddeeffg"})
    void invalidatePasswordTest(String value) {

        assertThatCode(() -> passwordValidator.validate(value))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessage("비밀번호는 최소 8자 이상 12자 이하여야 한다.");
    }
```

> [https://www.baeldung.com/parameterized-tests-junit-](https://www.baeldung.com/parameterized-tests-junit-5)5
> 

*PasswordValidator.class*

```java

public class PasswordValidator {

    public void validate(String password) {
        int length = password.length();

        if (length < 8 || length > 12) {
            throw new IllegalArgumentException("비밀번호는 최소 8자 이상 12자 이하여야 한다.");
        }
    }
}
```

---

### ✅ 요구사항 추가

- 랜덤 문자열 생성으로 임시 비밀번호를 생성하도록 수정
- 비밀번호를 최초 생성(초기화)하는 클래스 추가

### ✅ 코드작성

> `RandomPasswordGenerator` : 랜덤 문자열 생성
> 

> `User` : 비밀번호 최초 생성 역할
> 

*RandomPasswordGenerator.class*

```java
// 길이와 값을 랜덤하게 생성하는 로직이 있다고 가정함
public class RandomPasswordGenerator {

	public String generatePassword() { ... }
}
```

*User.class*

```java

public class User {
    private String password;

    public void initPassword() {
        RandomPasswordGenerator randomPasswordGenerator = new RandomPasswordGenerator();
        String randomPassword = randomPasswordGenerator.generatePassword();

        if(randomPassword.length() >= 8 && randomPassword.length() <= 12) {
            this.password = randomPassword;
        }
    }

    public String getPassword() {
        return password;
    }
}

```

*UserTest.class*

```java
public class UserTest {

    @DisplayName("비밀번호를 초기화한다.")
    @Test
    void passwordInitTest() {
        // given
        User user = new User();

        // when
        user.initPassword();

        // then
        assertThat(user.getPassword()).isNotNull();
    }
}
```

> 랜덤하게 비밀번호 값이 생성되기 때문에 이 테스트 코드는 pass/fail이 확률적으로 나타나게 될 것이다.
> 

### 🤔 어떻게 해야 pass, fail의 경우의 테스트를 유닛 테스트 코드로 작성하면서 결합도가 너무 높지 않게 할 수 있을까?

*User.class*

```java

public class User {
    private String password;

    public void initPassword() {
        RandomPasswordGenerator randomPasswordGenerator = new RandomPasswordGenerator();
        String randomPassword = randomPasswordGenerator.generatePassword();

        if(randomPassword.length() >= 8 && randomPassword.length() <= 12) {
            this.password = randomPassword;
        }
    }

    public String getPassword() {
        return password;
    }
}

```

> 해당 라인에서 생성되는 결과를 직접 컨트롤 할 수 없기 때문이다.
> 

따라서 이 부분을 컨트롤 가능하게끔 코드를 수정한다.

*PasswordGeneratePolicy.interface*

```java
public interface PasswordGeneratePolicy {
    String generatePassword();
}
```

> 비밀번호 생성 클래스 상위에 인터페이스를 둬서 결합을 느슨하게 할 목적
> 

*RandomPasswordGenerator.class*

```java
// 길이와 값을 랜덤하게 생성하는 로직이 있다고 가정함
public class RandomPasswordGenerator implements PasswordGeneratePolicy{

	@Override
	public String generatePassword() { ... }
}
```

*User.class*

```java

public class User {
    private String password;

    public void initPassword(PasswordGeneratorPolicy passwordGeneratorPolicy) {
		    // 삭제
        // RandomPasswordGenerator randomPasswordGenerator = new RandomPasswordGenerator();   
        String randomPassword = passwordGeneratorPolicy.generatePassword();

        if(randomPassword.length() >= 8 && randomPassword.length() <= 12) {
            this.password = randomPassword;
        }
    }

    public String getPassword() {
        return password;
    }
}

```

> 문제가 됐던 라인을 지우고, 컨트롤 불가능한 기능을 담당하는 클래스를 외부로부터 주입받도록 수정 → 결합도 감소
> 

`initPassword` 가 인터페이스를 받아서 그 결과로 validate를 진행하게 했으므로 파라미터를 컨트롤해주면 된다.

*UserTest.class*

```java
public class UserTest {

    @DisplayName("비밀번호 초기화에 성공한다.")
    @Test
    void validPasswordInitTest() {
        // given
        User user = new User();

        // when
        user.initPassword(new ValidPasswordGenerator());

        // then
        assertThat(user.getPassword()).isNotNull();
    }
    
    @DisplayName("비밀번호 초기화에 실패한다.")
    @Test
    void wrongPasswordInitTest() {
        // given
        User user = new User();
        
        // user.initPassword(new WrongPasswordGenerator());

        // when, then
        assertThatThrownBy(() -> user.initPassword(new WrongPasswordGenerator()))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessage("비밀번호는 최소 8자 이상 12자 이하여야 한다.");
    }
}
```

> 운영 로직에서는 랜덤하게 비밀번호가 전달이 되었지만, 테스트 환경에서는 직접 구분지어 전달하여 원하는 결과를 테스트 할 수 있게 되었다.
> 

---

### 💣 결론

테스트 하기 쉽게 코드를 작성하다 보니 결합도가 강해지지 않게끔 설계가 가능하였다.

[Humble Object Pattern](https://www.notion.so/Humble-Object-Pattern-1bc1f679d4cb805090bfedfcfece0734?pvs=21)
