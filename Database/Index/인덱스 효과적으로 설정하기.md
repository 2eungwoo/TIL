## INTRO

그럼 어떻게 인덱스를 효과적으로 설정하느냐?????

예전에 프로젝트 진행했을 때 계속해서 추가되는 요구사항에 따라서 인덱스 설정 작업이 계속 변화됐던 기억이 있다. 데이터 모델 자체가 수정되거나 쿼리 패턴이 바뀌어야 하거나 하는 이유로 인덱스 설정을 바꿔야 했는데, 이 때마다 성능에 대한 고려를 안 해볼 수가 없었다.

특히 어떤 컬럼에, 어떤 경우에 인덱스를 걸어주는 것이 최적인지에 대한 확신이 없었는데 한번 알아보자

## 인덱스 특징

### 인덱스는 WHERE 절에서 효과가 있다.

인덱스가 걸려있지 않은 데이터를 검색할 때에는 조건에 맞는 행을 찾기 위해 전체 테이블 스캔을 진행하므로, 특정 조건을 명시하는 where 절에 사용되는 컬럼에 인덱스를 걸면 영향만점이다.

### 그럼 최대한 모든 조건에 걸어주는게 좋은가?

인덱스는 단일 인덱스를 여러 개 생성할 수도 있고, 여러 컬럼을 묶어 복합 인덱스로 구성할 수도 있다.

그러나 무조건 많이 설정한다고 해서 검색 속도 향상에 효과가 있는 것은 아니다. 인덱스는 데이터베이스 메모리를 사용하여 테이블 형태로 저장되므로 개수와 저장 공간은 비례한다.

따라서 

- 조회 시 자주 사용되며
- 고유한 값

위주로 인덱스를 설정하는 것이 좋다.

### SELECT 외에 INSERT, UPDATE, DELETE

`SELECT` 쿼리에서 성능이 잘 뽑힌다는 건 알았고, 나머지 DML들은?

`UPDATE` , `DELETE` 는 WHERE 절에 설정된 인덱스로 조건을 붙여주면 조회 시 성능은 크게 저하되지 않으나 (업데이트 해야하는 데이터를 찾는 속도에는 도움, but 업데이트 자체는 x)`INSERT` 의 경우 새로운 데이터가 추가되면서 기존 인덱스 페이지에 저장되어 있던 정보가 수정되어야 하므로 효율이 그다지 좋지 않다. 

## 어떻게 했었나?

지난 프로젝트에서 인덱스 설정 후보 컬럼을 정해줬던 기준은 다음과 같았다.

### 1. 카디널리티

**카디널리티가 높을 수록 적합하다**

→ 한 컬럼이 갖고 있는 값의 중복 정도가 낮을 수록 좋다.

> ex )성별 컬럼은 도메인이 남성/여성 밖에 없으므로 중복 정도가 높을 수밖에 없으므로 카디널리티가 낮다고 할 수 있다.
> 

### 2. 선택도

**선택도(selectivity)가 낮을 수록 적합하다(5~10%)**

→ 데이터에서 특정 값을 얼마나 잘 선택할 수 있는지에 대한 지표

```sql
(컬럼 특정 값의 row 개수 / 테이블의 총 row 수) * 100
(컬럼 값들의 평균 row 개수 / 테이블의 총 row 수) * 100
```

> ex) 학생 테이블에 `학번`, `성별`  이 있다고 해보자 (전체10, 남자5, 여자5)
> 

> `학번` 은 고유한 값이므로 (1/10) * 100 = 10%
> 

> `성별` 은 5명, 5명 씩 있으므로 (5/10) * 100 = 50%
> 

### 3. 활용도

**활용도가 높을 수록 적합하다.**

→ 해당 컬럼이 실제 얼마나 활용되는지에 대한 값이다.

→ 주로 쿼리를 날릴 때 where 절에 자주 사용되는지 보고 판단했다.

## 새로 알게된 것들, 어떤 기준으로 컬럼을 선정할지?

보통 조건절이나 조인 절에 사용하는 컬럼을 인덱스 컬럼으로 설정하는 것이 좋다.

다음 5가지는 인덱스 대상 후보 컬럼을 결정할 때에 고려해야할 사항이다.

- 분포도가 좋은 컬럼인가?
- 갱신이 자주 발생하지 않는 컬럼인가?
- 조건절에서 자주 사용되는 컬럼인가?
- 조인의 연결고리에 사용되는 컬럼인가?
- 소트 발생을 제거하는 컬럼인가?

### 1. 분포도가 좋은 컬럼인가?

`분포도` 란 전체 레코드에서 식별 가능한 수에 대한 백분율이다. 예를 들어 `성별` 컬럼은 분포도가 50%인 것이다.

`학번` 컬럼은 전체 100이라고 하면 분포도가 1%이다. 식별 가능한 수가 클수록 분포도는 낮으며, 분포도가 낮을수록 분포도가 좋다고 말하낟. 

분포도가 좋은 컬럼은 인덱스 후보 컬럼이 될 수 있으나 무조건 분포도에만 의존하는 것은 좋지 않다.

예를 들어 `고객` 테이블에서 생년월일 컬럼이 있다고 하면, 분포도는 확률적으로 매우 낮은 값을 가지지만 where절에 사용될 정도로 중요한 컬럼이 아니기 때문이다.

`주문` 테이블에 `배송 여부` 컬럼이 있다고 가정했을 때 이 컬럼의 식별 가능한 수는 Y/N 으로, 분포도가 50%이다. 분포도 값이 높은 편이지만 실제 테이블에서 레코드 값은 대부분 Y 일 것이다. 

때에 따라서는 논리적으로 판단했을 때만 고려하면 분포도가 좋지 않으니 적합하지 않겠지만 물리적인 실제 값을 고려했을 때 컬럼 특징에 때라 분포도가 극단적으로 쏠려있을 수 있다. 

따라서 아래와 같은 쿼리에서 `배송 여부` 컬럼은 인덱스 후보 컬럼으로 적합하다고 볼 수 있다.

```sql
SELECT *
FROM 주문
WHERE 배송여부 = 'N' 
```

### 2. 갱신이 자주 발생하지 않는 컬럼인가?

인덱스 컬럼이 자주 삽입되면, 인덱스 밸런싱이 깨진다. 테이블에서 처리 작업을 할 때, 인덱스에 대한 정보도 반영해야 하기 때문이다. (링크)

따라서 가급적이면 `UPDATE` 항목에서 사용하는 컬럼은 인덱스 후보에서 제외하는 것이 좋다.

### 3. 조건절에서 자주 사용되는 컬럼인가?

이 말의 의미는, where절 자체에서 쓰임새가 많느냐도 있지만 범용적인 조건절이냐 라는 의미가 더 크다. 

특정 테이블의 컬럼에 대해 생성된 인덱스는 그 테이블의 빠른 처리 속도를 돕지만, 너무 많은 인덱스를 생성하면 쓰기 작업에서 부하가 커지므로 조건절에서 자주 사용되는, 범용적으로 많이 사용되는 컬럼에 대해서만 적절하게인덱스를 생성하라는 말이다.

![O_44](https://github.com/user-attachments/assets/51f357a4-4573-4d5b-87c0-671527fc430c)

만약 하루 쿼리 구동 횟수가 다음과 같다고 해보자(위에는 컬럼임)

- 쿼리1 : 100/day (상단)
- 쿼리2 : 10/day (좌하단)
- 쿼리3 : 1000/day (우하단)

> 일일 쿼리 횟수 : `C > A > B`
> 

> 조건절에 자주 사용 컬럼 : `ABC > AB = AC = BC > A = B = C`
> 

만약 위와 같은 상황이면 다음과 같이 결합 인덱스를 생각해볼 수 있다.

- `idx = ABC+AC+BC+C`

가장 많이 사용되는 `쿼리3`을 기준으로 인덱스를 만들고 다른 쿼리도 범용적으로 사용할 수 있도록 조건절에서 자주 사용하는 컬럼을 결합 인덱스의 선행으로 둔 것이다.

### 4. 조인의 연결고리에 사용되는 컬럼인가?

인덱스는 조건절에서 사용되기도 하고 조인 절에서 사용되기도 한다~~. (애초에 조인을 from A,B where [A.id](http://A.id) = [B.id](http://B.id) 이렇게 걸면 조건절이나 다름없지않을까)~~

조건절에서 사용하는 인덱스는 최초로 접근하는 테이블을 결정하는 중요한 인덱스이며, 데이터 접근 범위를 줄여주는 역할을 한다. 일반적으로 조인의 방법에는 아래와 같이 3가지가 있다.(from chatGPT)

- `Nested Loop Join` : 두 테이블의 각 행을 하나씩 비교하여 일치하는 행을 찾는 방법. 작은 테이블을 기준으로 큰 테이블을 반복적으로 검색하면서 조인을 수행하는 방식. → 이 방식이 대부분일 것이다. 조인 절에 인덱스가 반드시 있어야 한다.
- `Sort Merge Join` : 두 테이블을 정렬한 후, 정렬된 데이터를 비교하면서 일치하는 행을 찾는 방법. 대규모 데이터셋에서 효율적일 수 있음.
- `Hash Join` : 해시 테이블을 이용하여 두 테이블을 조인하는 방법. 한 테이블을 해시로 변환하여 메모리 상에 저장하고, 다른 테이블의 값을 해시로 비교하며 조인하는 방식.

인덱스 존재 여부에 따라 옵티마이저는 어느 조인을 택할지에 대해 선택이 가능하다.

### 5. 소트 발생을 제거하는 컬럼인가?

인덱스는 기본적으로 `위치 정보(포인터) + 순서 정보(키)` 로 구성된다. 인덱스는 조건절이나 조인절 말고도 `ORDER BY` 절에 있는 컬럼도 인덱스 후보 컬럼으로 사용할 수 있다. 해당 컬럼으로 인덱스를 생성하면 정렬이 발생하지 않고 데이터를 정렬된 상태로 가져올 수 있다.

그렇다고 항상 `ORDER BY` 절에 인덱스를 사용하는 것이 좋다고 할 수 없다. 인덱스를 생성할 떄 발생하는 부하와 정렬 발생 시 부하를 비교해보고 결정한다. 만약 정렬 부하가 더 크다면 인덱스 후보로 생각할 수 있는 것이다.

하지만 이를 명확하게 수치로 비교하기는 힘들다. 데이터베이스에서 일반적으로 가져온 데이터를 정렬하는 부하가 훨씬 더 크므로 `ORDER BY` 절 컬럼은 인덱스 후보 컬럼으로 중요하게 사용되는 경우가 많다.

```sql
SELECT *
FROM 주문
WHERE 상품코드 = 'A123'
	AND 배송여부 = 'N'
ORDER BY 주문일자 DESC 
```

여기서 결합 인덱스를 생성하는 다음 두 가지 방식이 있을 것이다.

1. 상품코드+배송여부
2. 상품코드+배송여부+주문일자

정렬 부하가 인덱스 부하보다 크면 두 번째 방식을 선택하고 아니면 첫 번째를 선택하면 된다.

이 와중에도 복합 인덱스를 구성할 때 컬럼을 어떤 순서로 배치하느냐 역시 위의 여러 가지 요소를 고려하여 배치하면 된다.

`reference` 

https://yurimkoo.github.io/db/2020/03/14/db-index.html

개발자를 위한 인덱스 생성과 SQL 작성 노하우 - 이병국
